<html>
<head>
    <title></title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../thirdparty/require.js"></script>
</head>
<body style="margin:0px;">
    <canvas id="Main" style="background-color:#06b3db;"></canvas>
    <script type="text/javascript">
        requirejs.config({
            'baseUrl' : '../src',
            'paths' : {
                '_' : '../thirdparty/lodash.compat',
                'glmatrix' : '../thirdparty/gl-matrix'
            },
            'shim' : {
                '_' : {
                    exports : '_'
                }
            }
        });

        require(['qtek',
                'text!../tests/shader/curlnoise.essl',
                'text!../tests/assets/models/LeePerrySmith/LeePerrySmith.js'], function(qtek, shaderStr, modelData){
            
            var qtek3d = qtek['3d'];
            var Shader = qtek3d.Shader;
            var pp_Node = qtek3d.compositor.Node;
            var compositor = new qtek3d.Compositor();

            var SIZE = 512;

            var renderer = new qtek3d.Renderer({
                canvas : document.getElementById( "Main")
            });
            renderer.resize(window.innerWidth, window.innerHeight);

            Shader.import(shaderStr);

            var parameters = {
                width : SIZE,
                height : SIZE,
                type : 'FLOAT',
                minFilter : 'NEAREST',
                magFilter : 'NEAREST',
                generateMipmaps : false
            };

            // var spawnNode = new pp_Node({
            //     shader : Shader.source("curlnoise.spawn"),
            //     outputs : {
            //         'position' : {
            //             parameters : parameters
            //         }
            //     }
            // });

            var noiseNode = new pp_Node({
                shader : Shader.source("curlnoise.noise"),
                outputs : {
                    'noise' : {
                        parameters : parameters
                    }
                }
            });

            var particleNode = new pp_Node({
                shader : Shader.source("curlnoise.particle"),
                inputs : {
                    // 'spawnTexture' : {
                    //     node : spawnNode,
                    //     pin : 'position'
                    // },
                    'noiseTexture' : {
                        node : noiseNode,
                        pin : 'noise'
                    }
                }
            });

            // compositor.add(spawnNode);
            compositor.add(noiseNode);
            compositor.add(particleNode);

            var sourceTexture = new qtek3d.texture.Texture2D(parameters);
            var targetTexture = new qtek3d.texture.Texture2D(parameters);

            var frameBuffer = new qtek3d.FrameBuffer();

            function swapParticleTexture(){
                var tmp = sourceTexture;
                sourceTexture = targetTexture;
                targetTexture = tmp;
            }

            particleNode.pass.on("beforerender", function(renderer){
                frameBuffer.attach(renderer.gl, targetTexture);
                frameBuffer.bind(renderer);
                particleNode.setParameter('particleTexture', sourceTexture);
            });
            particleNode.pass.on("afterrender", function(renderer){
                frameBuffer.unbind(renderer);
            });

            particleNode.setParameters({
                particleTextureSize : SIZE,
                noiseTextureSize : SIZE
            })

            // Scene
            var geo = new qtek3d.Geometry({
                useFaces : false,
                hint : 'DYNAMIC_DRAW'
            });
            for (var i = 0; i < SIZE; i++) {
                for (var j = 0; j < SIZE; j++) {
                    geo.attributes.position.value.push([i / SIZE, j / SIZE, 0]);
                }
            }
            var mat = new qtek3d.Material({
                shader : new qtek3d.Shader({
                    vertex : Shader.source("curlnoise.vertex"),
                    fragment : Shader.source("curlnoise.fragment")
                }),
                transparent : true,
                depthTest : false,
                // depthWrite : false,
                blend : function(_gl){
                    _gl.blendEquation(_gl.FUNC_ADD);
                    _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
                }
            });
            var particleSystem = new qtek3d.Mesh({
                geometry : geo,
                material : mat,
                mode : 'POINTS'
            });
            var scene = new qtek3d.Scene();
            scene.add(particleSystem);
            var camera = new qtek3d.camera.Perspective({
                aspect : window.innerWidth / window.innerHeight
            });
            camera.position.z = 0.3;
            camera.position.y = 0.3;
            camera.lookAt(scene.position);

            var spiritTexture = new qtek3d.texture.Texture2D();
            spiritTexture.image = generateSprite();
            mat.setUniform("spiritTexture", spiritTexture);
            mat.setUniform("color", [0.5, 0.3, 0.1]);

            var control = new qtek3d.plugin.OrbitControl({
                camera : camera,
                canvas : renderer.canvas,
                sensitivity : 0.4
            });
            control.enable();

            // Dragon
            var data = JSON.parse(modelData);
            var loader = new qtek.loader.three.Model();
            var meshList = loader.parse(data);
            var root = new qtek3d.Node();
            var material = new qtek3d.Material({
                shader : qtek3d.shader.library.get('buildin.lambert'),
                // transparent : true
            });
            // meshList[0].geometry = new qtek3d.geometry.Sphere({
            //     radius : 0.1
            // });
            root.scale.set(0.50, 0.50, 0.50);
            // material.setUniform('color', [1.0, 1.0, 1.0]);
            // material.setUniform('lineWidth', 0.7);
            meshList.forEach(function(mesh) {
                mesh.geometry.generateBarycentric();
                mesh.material = material;
                root.add(mesh);
            });
            scene.add(root);
            var light = new qtek3d.light.Directional();
            light.position.set(0, 0.3, 0.3);
            light.lookAt(scene.position);
            scene.add(light);

            // 
            var spawnTexture = new qtek3d.texture.Texture2D(parameters);
            var pixels = new Float32Array(SIZE * SIZE * 4);
            var positions = meshList[0].geometry.attributes.position.value;
            var cursor = 0;
            var len = positions.length;
            for (var i = 0; i < SIZE * SIZE; i++) {
                pixels[cursor++] = positions[i % len][0] * 0.50;
                pixels[cursor++] = positions[i % len][1] * 0.50;
                pixels[cursor++] = positions[i % len][2] * 0.50;
                pixels[cursor++] = Math.random() * 4;
            }
            spawnTexture.width = SIZE;
            spawnTexture.height = SIZE;
            spawnTexture.pixels = pixels;
            particleNode.setParameter("spawnTexture", spawnTexture);


            var time = new Date().getTime();
            var elapsedTime = 0;

            function update(){
                var currentTime = new Date().getTime();
                var deltaTime = (currentTime - time) / 1000;
                elapsedTime += deltaTime;
                time = currentTime;

                // spawnNode.setParameter("elapsedTime", elapsedTime);
                noiseNode.setParameter("elapsedTime", elapsedTime);
                particleNode.setParameter("elapsedTime", elapsedTime);
                particleNode.setParameter("deltaTime", deltaTime);
                compositor.render(renderer);

                mat.setUniform("particleTexture", targetTexture);
                renderer.render(scene, camera);

                swapParticleTexture();

                setTimeout(update, 50);
            }
            setTimeout(update, 50);

            function generateSprite(){
                var canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;

                var context = canvas.getContext( '2d' );

                context.beginPath();
                context.arc( 64, 64, 60, 0, Math.PI * 2, false) ;
                context.closePath();

                context.restore();

                var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);

                gradient.addColorStop( 0, 'rgba(255,255,255,1)' );
                gradient.addColorStop( 1, 'rgba(255,255,255,0.0)' );

                context.fillStyle = gradient;

                context.fill();
                return canvas;
            }
        });
    </script>
</body>
</html>