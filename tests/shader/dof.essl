// Sousa_Graphics_Gems_CryENGINE3, Siggraph 2013
@export dof.coc

uniform sampler2D depth;

uniform float zNear: 0.1;
uniform float zFar: 2000;

uniform float focalPlane: 6;
// Object in range are perfectly in focus
uniform float focalRange: 1;
// 30mm
uniform float focalLength: 30;
// f/2.8
uniform float fstop: 0.36;

varying vec2 v_Texcoord;

@import qtek.util.encode_float

void main()
{
    float z = texture2D(depth, v_Texcoord).r;

    float dist = 2.0 * zNear * zFar / (zFar + zNear - z * (zFar - zNear));

    float aperture = 1.0 / fstop;

    float coc;

    float uppper = focalPlane + focalRange;
    float lower = focalPlane - focalRange;
    if (dist <= uppper && dist >= lower) {
        // Object in range are perfectly in focus
        coc = 0.5;
    }
    else {
        // Adjust focalPlane
        float focalAdjusted = dist > uppper ? uppper : lower;

        // GPU Gems Depth of Field: A Survey of Techniques
        coc = aperture * (focalLength * (dist - focalAdjusted)) / (dist * (focalAdjusted - focalLength));
        // Clamp on the near focus plane and far focus plane
        // PENDING
        // Float value can only be [0.0 - 1.0)
        coc = clamp(coc, -0.4, 0.4) / 0.4001;
        coc = coc * 0.5 + 0.5;
    }

    // R: coc, < 0.5 is near field, > 0.5 is far field
    gl_FragColor = encodeFloat(coc);
}

@end

// Premutiply with coc to avoid bleeding in upsampling
@export dof.premutiply

uniform sampler2D texture;
uniform sampler2D coc;
varying vec2 v_Texcoord;

@import qtek.util.rgbm

@import qtek.util.decode_float

void main() {
    float fCoc = max(abs(decodeFloat(texture2D(coc, v_Texcoord)) * 2.0 - 1.0), 0.01);
    gl_FragColor = encodeHDR(
        vec4(decodeHDR(texture2D(texture, v_Texcoord)).rgb * fCoc, 1.0)
    );
}
@end


// Get min coc tile
@export dof.min_coc
uniform sampler2D coc;
varying vec2 v_Texcoord;
uniform vec2 textureSize : [512.0, 512.0];

@import qtek.util.float

void main()
{

    vec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / textureSize.xyxy;

    float coc = decodeFloat(texture2D(coc, v_Texcoord + d.xy));
    coc = min(coc, decodeFloat(texture2D(texture, v_Texcoord + d.zy)));
    coc = min(coc, decodeFloat(texture2D(texture, v_Texcoord + d.xw)));
    coc = min(coc, decodeFloat(texture2D(texture, v_Texcoord + d.zw)));

    gl_FragColor = encodeFloat(coc);
}

@end


// Get max coc tile
@export dof.max_coc
uniform sampler2D coc;
varying vec2 v_Texcoord;
uniform vec2 textureSize : [512.0, 512.0];

@import qtek.util.float

void main()
{

    vec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / textureSize.xyxy;

    float coc = decodeFloat(texture2D(coc, v_Texcoord + d.xy));
    coc = max(coc, decodeFloat(texture2D(texture, v_Texcoord + d.zy)));
    coc = max(coc, decodeFloat(texture2D(texture, v_Texcoord + d.xw)));
    coc = max(coc, decodeFloat(texture2D(texture, v_Texcoord + d.zw)));

    gl_FragColor = encodeFloat(coc);
}

@end


@export dof.hexagonal_blur_frag

@import qtek.util.decode_float

vec4 doBlur(sampler2D colorTexture, vec2 offset) {
    vec4 color = vec4(0.0);
    float weightAll = 0.0;
    float kernelWeight = 1.0 / float(KERNEL_SIZE);
    for(int i = 0; i < KERNEL_SIZE; i++){
        vec2 coord = v_Texcoord + offset * float(i);
        vec4 cocTexel = texture2D(coc, coord);

        float w = kernelWeight;
#ifdef COC_ENABLED
        w *= abs(decodeFloat(cocTexel) * 2.0 - 1.0);
#endif
        weightAll += w;
        color += decodeHDR(texture2D(colorTexture, coord)) * w;
    }

    return color / weightAll;
}

@end


@export dof.hexagonal_blur_1

#define KERNEL_SIZE 5

uniform sampler2D texture;

#ifdef COC_ENABLED
uniform sampler2D coc;
#endif

varying vec2 v_Texcoord;

uniform float blurSize : 1.0;

uniform vec2 textureSize : [512.0, 512.0];

@import qtek.util.rgbm

@import dof.hexagonal_blur_frag

void main()
{
    vec2 offset = blurSize / textureSize;
#ifdef COC_ENABLED
    offset *= abs(decodeFloat(texture2D(coc, v_Texcoord)) * 2.0 - 1.0);
#endif

    // Top
    gl_FragColor = encodeHDR(doBlur(texture, vec2(0.0, offset.y)));
}

@end

@export dof.hexagonal_blur_2

#define KERNEL_SIZE 5

uniform sampler2D texture;

#ifdef COC_ENABLED
uniform sampler2D coc;
#endif

varying vec2 v_Texcoord;

uniform float blurSize : 1.0;

uniform vec2 textureSize : [512.0, 512.0];

@import qtek.util.rgbm

@import dof.hexagonal_blur_frag

void main()
{
    vec2 offset = blurSize / textureSize;
#ifdef COC_ENABLED
    offset *= abs(decodeFloat(texture2D(coc, v_Texcoord)) * 2.0 - 1.0);
#endif
    offset.y /= 2.0;

    // Down left
    gl_FragColor = encodeHDR(doBlur(texture, -offset));
}
@end

@export dof.hexagonal_blur_3

#define KERNEL_SIZE 5

uniform sampler2D texture1;
uniform sampler2D texture2;

#ifdef COC_ENABLED
uniform sampler2D coc;
#endif

varying vec2 v_Texcoord;

uniform float blurSize : 1.0;

uniform vec2 textureSize : [512.0, 512.0];

@import qtek.util.rgbm

@import dof.hexagonal_blur_frag

void main()
{
    vec2 offset = blurSize / textureSize;

#ifdef COC_ENABLED
    offset *= abs(decodeFloat(texture2D(coc, v_Texcoord)) * 2.0 - 1.0);
#endif

    offset.y /= 2.0;
    vec2 vDownRight = vec2(offset.x, -offset.y);

    // Down left
    vec4 color1 = doBlur(texture1, -offset);
    // Down right
    vec4 color2 = doBlur(texture1, vDownRight);
    // Down right
    vec4 color3 = doBlur(texture2, vDownRight);

    gl_FragColor = encodeHDR((color1 + color2 + color3) / 3.0);
}

@end


@export dof.composite

uniform sampler2D original;
uniform sampler2D blurred;
uniform sampler2D coc;
varying vec2 v_Texcoord;

@import qtek.util.decode_float
@import qtek.util.rgbm

void main()
{
    vec4 blurredColor = decodeHDR(texture2D(blurred, v_Texcoord));
    vec4 originalColor = decodeHDR(texture2D(original, v_Texcoord));
    vec4 cocTexel = texture2D(coc, v_Texcoord);
    float fCoc = abs(decodeFloat(cocTexel) * 2.0 - 1.0);
    blurredColor.rgb /= max(fCoc, 0.01);
    fCoc = smoothstep(0.0, 1.0, fCoc);

    gl_FragColor = encodeHDR(vec4(mix(originalColor.rgb, blurredColor.rgb, fCoc), 1.0));

    // gl_FragColor = vec4(texture2D(coc, v_Texcoord).rgb, 1.0);
}

@end