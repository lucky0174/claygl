@export qtek.deferred.directional_light

@import qtek.deferred.chunk.light_head

@import qtek.deferred.chunk.light_equation

uniform vec3 lightDirection;
uniform vec3 lightColor;

uniform vec3 eyePosition;

#ifdef SHADOWMAP_ENABLED
uniform sampler2D lightShadowMap;
uniform float lightShadowMapSize;
uniform mat4 lightMatrices[SHADOW_CASCADE];
uniform float shadowCascadeClipsNear[SHADOW_CASCADE];
uniform float shadowCascadeClipsFar[SHADOW_CASCADE];
#endif

@import qtek.plugin.shadow_map_common

void main()
{
    @import qtek.deferred.chunk.gbuffer_read

    vec3 L = -normalize(lightDirection);
    vec3 V = normalize(eyePosition - position);

    vec3 H = normalize(L + V);
    float ndl = clamp(dot(N, L), 0.0, 1.0);
    float ndh = clamp(dot(N, H), 0.0, 1.0);
    float ndv = clamp(dot(N, V), 0.0, 1.0);

    gl_FragColor.rgb = lightEquation(
        lightColor, diffuseColor, specularColor, ndl, ndh, ndv, glossiness
    );

#ifdef SHADOWMAP_ENABLED
    float shadowContrib = 1.0;
    for (int i = 0; i < SHADOW_CASCADE; i++) {
        if (
            z >= shadowCascadeClipsNear[i] &&
            z <= shadowCascadeClipsFar[i]
        ) {
            shadowContrib = computeShadowContrib(
                lightShadowMap, lightMatrices[i], position, lightShadowMapSize,
                vec2(1.0 / float(SHADOW_CASCADE), 1.0),
                vec2(float(i) / float(SHADOW_CASCADE), 0.0)
            );
        }
    }

    gl_FragColor.rgb *= shadowContrib;
#endif

    gl_FragColor.a = 1.0;
}
@end
