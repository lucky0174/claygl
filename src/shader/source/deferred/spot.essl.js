define(function () {
return "@export buildin.deferred.spot_light\n\n@import buildin.deferred.chunk.light_head\n\n@import buildin.deferred.chunk.light_equation\n\n@import buildin.util.calculate_attenuation\n\nuniform vec3 lightPosition;\nuniform vec3 lightDirection;\nuniform vec3 lightColor;\nuniform float umbraAngleCosine;\nuniform float penumbraAngleCosine;\nuniform float lightRange;\nuniform float falloffFactor;\n\nuniform vec3 eyePosition;\n\nvoid main()\n{\n    @import buildin.deferred.chunk.gbuffer_read\n\n    vec3 L = lightPosition - position;\n    vec3 V = normalize(eyePosition - position);\n\n    float dist = length(L);\n    L /= dist;\n\n    float attenuation = lightAttenuation(dist, lightRange);\n    float c = dot(-lightDirection, L);\n\n    float falloff = clamp((c - umbraAngleCosine) / (penumbraAngleCosine - umbraAngleCosine), 0.0, 1.0);\n    falloff = pow(falloff, falloffFactor);\n\n    vec3 H = normalize(L + V);\n    float ndl = clamp(dot(N, L), 0.0, 1.0);\n    float ndh = clamp(dot(N, H), 0.0, 1.0);\n\n    // Diffuse term\n    gl_FragColor.rgb = lightColor * ndl * (1.0 - falloff) * attenuation;\n    if (dot(gl_FragColor.rgb, vec3(1.0)) == 0.0) // Reduce blending\n    {\n        discard;\n    }\n    gl_FragColor.a = dot(LUM, gl_FragColor.rgb * D_Phong(glossiness, ndh));\n}\n@end\n";
});