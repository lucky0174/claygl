define(function () {
return "@export buildin.deferred.tube_light\n\n@import buildin.deferred.chunk.light_head\n\n@import buildin.util.calculate_attenuation\n\n@import buildin.deferred.chunk.light_equation\n\nuniform vec3 lightPosition;\nuniform vec3 lightColor;\nuniform float lightRange;\nuniform vec3 lightExtend;\n\nuniform vec3 eyePosition;\n\nvarying vec3 v_Position;\n\nvoid main()\n{\n    @import buildin.deferred.chunk.gbuffer_read\n\n    vec3 L = lightPosition - position;\n\n    vec3 V = normalize(eyePosition - position);\n\n    // Light pos and irradiance fix\n    vec3 R = reflect(V, N);\n\n    vec3 L0 = lightPosition - lightExtend - position;\n    vec3 L1 = lightPosition + lightExtend - position;\n    vec3 LD = L1 - L0;\n\n    float len0 = length(L0);\n    float len1 = length(L1);\n    float irra = 2.0 * clamp(dot(N, L0) / (2.0 * len0) + dot(N, L1) / (2.0 * len1), 0.0, 1.0);\n\n    float LDDotR = dot(R, LD);\n    float t = (LDDotR * dot(R, L0) - dot(L0, LD)) / (dot(LD, LD) - LDDotR * LDDotR);\n    t = clamp(t, 0.0, 1.0);\n    L = L0 + t * LD;\n    // FIXME attenuation integration\n    float dist = length(L);\n    L /= dist;\n\n    vec3 H = normalize(L + V);\n\n    float ndh = clamp(dot(N, H), 0.0, 1.0);\n\n    // Diffuse term\n\n    gl_FragColor.rgb = lightColor * irra * lightAttenuation(dist, lightRange);\n    if (dot(gl_FragColor.rgb, vec3(1.0)) == 0.0) // Reduce blending\n    {\n        discard;\n    }\n\n    // Specular fix\n    // glossiness = clamp(glossiness - 0.0 / 2.0 / dist, 0.0, 1.0);\n\n    // Specular luminance\n    gl_FragColor.a = dot(LUM, gl_FragColor.rgb * D_Phong(glossiness, ndh));\n}\n@end";
});