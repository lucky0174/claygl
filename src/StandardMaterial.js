define(function (require) {

    'use strict';

    var Material = require('./Material');

    var Shader = require('./Shader');
    // Import standard shader
    Shader['import'](require('./shader/source/standard.essl'));

    var shaderLibrary = {};
    var shaderUsedCount = {};

    var keyOffsets = {

        diffuseMap: 256,

        normalMap: 256 * 2,

        roughnessMap: 256 * 4,

        metalnessMap: 256 * 8,

        environmentMap: 256 * 16,

        environmentMapPrefiltered: 256 * 32,

        brdfLookup: 256 * 64,

        linear: 256 * 128,

        encodeRGBM: 256 * 256
    };

    function makeKey (enabledMaps, jointCount, environmentMapPrefiltered, linear, encodeRGBM) {
        // jointCount from 0 to 255
        var key = jointCount;
        for (var i = 0; i < enabledMaps.length; i++) {
            key += keyOffsets[enabledMaps[i]];
        }
        if (environmentMapPrefiltered) {
            key += keyOffsets.environmentMapPrefiltered;
        }
        if (linear) {
            key += keyOffsets.linear;
        }
        if (encodeRGBM) {
            key += keyOffsets.encodeRGBM;
        }

        return key;
    }

    function allocateShader (enabledMaps, jointCount, environmentMapPrefiltered, linear, encodeRGBM) {
        var key = makeKey(enabledMaps, jointCount, environmentMapPrefiltered, linear, encodeRGBM);
        var shader = shaderLibrary[key];

        if (!shader) {
            shader = new Shader({
                vertex: Shader.source('qtek.standard.vertex'),
                fragment: Shader.source('qtek.standard.fragment')
            });
            shader.enableTexture(enabledMaps);
            shader.define('fragment', 'USE_METALNESS');
            shader.define('fragment', 'USE_ROUGHNESS');
            if (jointCount) {
                shader.define('vertex', 'SKINNING');
                shader.define('vertex', 'JOINT_COUNT', jointCount);
            }
            if (environmentMapPrefiltered) {
                shader.define('fragment', 'ENVIRONMENTMAP_PREFILTER');
            }
            if (linear) {
                shader.define('fragment', 'SRGB_DECODE');
            }
            if (encodeRGBM) {
                shader.define('fragment', 'RGBM_ENCODE');
            }

            shaderLibrary[key] = shader;
            shaderUsedCount[key] = 0;
        }
        shaderUsedCount[key]++;

        shader.__key__ = key;

        return shader;
    }
    function releaseShader (shader, _gl) {
        var key = shader.__key__;
        if (shaderLibrary[key]) {
            shaderUsedCount[key]--;
            if (!shaderUsedCount[key]) {
                delete shaderLibrary[key];
                delete shaderUsedCount[key];

                if (_gl) {
                    // Since shader may not be used on any material. We need to dispose it
                    shader.dispose(_gl);
                }
            }
        }
    }

    var textureProperties = ['diffuseMap', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissionMap', 'environmentMap', 'brdfLookup'];
    var simpleProperties = ['color', 'emission', 'emissionIntensity', 'alpha', 'roughness', 'metalness', 'uvRepeat', 'uvOffset'];
    var allProperties = textureProperties.concat(simpleProperties);

    var StandardMaterial = Material.derive(function () {

        /**
         * @type {Array.<number>}
         * @name color
         * @default [1, 1, 1]
         */

        /**
         * @type {Array.<number>}
         * @name emission
         * @default [0, 0, 0]
         */

        /**
         * @type {number}
         * @name emissionIntensity
         * @default 0
         */

        /**
         * @type {number}
         * @name roughness
         * @default 0.5
         */

        /**
         * @type {number}
         * @name metalness
         * @default 0.5
         */

        /**
         * @type {number}
         * @name alpha
         * @default 1
         */

        /**
         * @type {boolean}
         * @name transparent
         * @default 0.5
         */

        /**
         * @type {qtek.Texture2D}
         * @name diffuseMap
         */

        /**
         * @type {qtek.Texture2D}
         * @name normalMap
         */

        /**
         * @type {qtek.Texture2D}
         * @name roughnessMap
         */

        /**
         * @type {qtek.Texture2D}
         * @name metalnessMap
         */
        /**
         * @type {qtek.Texture2D}
         * @name emissionMap
         */

        /**
         * @type {qtek.TextureCube}
         * @name environmentMap
         */

        /**
         * BRDF Lookup is generated by qtek.util.cubemap.integrateBrdf
         * @type {qtek.Texture2D}
         * @name brdfLookup
         */


        /**
         * @type {Array.<number>}
         * @name uvRepeat
         * @default [1, 1]
         */

        /**
         * @type {Array.<number>}
         * @name uvOffset
         * @default [0, 0]
         */

        /**
         * @type {number}
         * @name jointCount
         * @default 0
         */

        /**
         * @type {boolean}
         * @name environmentMapPrefiltered
         */

        /**
         * @type {boolean}
         * @name linear
         */

        /**
         * @type {boolean}
         * @name encodeRGBM
         */

        // Dummy uniforms to avoid property setting not work on initializing.
        var uniforms = {};
        for (var i = 0; i < allProperties.length; i++) {
            uniforms[allProperties[i]] = {
                // type: 'dummy',
                value: null
            };
        }
        return {
            uniforms: uniforms
        };
    }, function () {
        // Default values
        this.color = this.color || [1, 1, 1];
        this.emission = this.emission || [0, 0, 0];
        this.emissionIntensity = this.emissionIntensity || 0;
        this.alpha = this.alpha == null ? 1 : this.alpha;

        this.roughness = this.roughness == null ? 0.5 : this.roughness;
        this.metalness = this.metalness || 0;

        this.uvRepeat = this.uvRepeat || [1, 1];
        this.uvOffset = this.uvOffset || [0, 0];

        // TODO Fixed maxMipmapLevel 5
        this.environmentMapPrefiltered = this.environmentMapPrefiltered || false;

        this.linear = this.linear || false;

        this.encodeRGBM = this.encodeRGBM || false;

    }, {

        _doUpdateShader: function (gl) {
            var enabledTextures = textureProperties.filter(function (name) {
                return !!this[name];
            }, this);
            if (this._shader) {
                releaseShader(this._shader, gl);
                this._shader.detached();
            }

            var shader = allocateShader(
                enabledTextures, this.jointCount || 0, this.environmentMapPrefiltered, this.linear, this.encodeRGBM
            );
            var originalUniforms = this.uniforms;

            // Ignore if uniform can use in shader.
            this.uniforms = shader.createUniforms();
            this._shader = shader;

            var uniforms = this.uniforms;
            this._enabledUniforms = Object.keys(uniforms);

            // Keep uniform
            for (var symbol in originalUniforms) {
                if (uniforms[symbol]) {
                    uniforms[symbol].value = originalUniforms[symbol].value;
                }
            }

            shader.attached();

            this._shaderDirty = false;
        },

        updateShader: function (gl) {
            if (this._shaderDirty) {
                this._doUpdateShader(gl);
                this._shaderDirty = false;
            }
        },

        attachShader: function () {
            // Do nothing.
            // console.warn('StandardMaterial can\'t change shader');
        },

        dispose: function (gl, disposeTexture) {
            if (this._shader) {
                releaseShader(this._shader);
            }
            Material.prototype.dispose.call(gl, disposeTexture);
        }
    });

    simpleProperties.forEach(function (propName) {
        Object.defineProperty(StandardMaterial.prototype, propName, {
            get: function () {
                return this.get(propName);
            },
            set: function (value) {
                this.setUniform(propName, value);
            }
        });
    });

    textureProperties.forEach(function (propName) {
        Object.defineProperty(StandardMaterial.prototype, propName, {
            get: function () {
                return this.get(propName);
            },
            set: function (value) {
                var oldVal = this.get(propName);
                this.setUniform(propName, value);

                if (!oldVal !== !value) {
                    this._shaderDirty = true;
                }
            }
        });
    });

    ['jointCount', 'linear', 'encodeRGBM'].forEach(function (propName) {
        var privateKey = '_' + propName;
        Object.defineProperty(StandardMaterial.prototype, propName, {
            get: function () {
                return this[privateKey];
            },
            set: function (value) {
                var oldVal = this[privateKey];
                this[privateKey] = value;
                if (oldVal !== value) {
                    this._shaderDirty = true;
                }
            }
        });
    });

    Object.defineProperty(StandardMaterial.prototype, 'shader', {
        get: function () {
            if (!this._shader) {
                this._shaderDirty = true;
                this.updateShader();
            }
            return this._shader;
        },
        set: function () {
            console.warn('StandardMaterial can\'t change shader');
        }
    });

    return StandardMaterial;
});