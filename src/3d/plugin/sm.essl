@export buildin.sm.depth.vertex

uniform mat4 worldViewProjection : WORLDVIEWPROJECTION;

attribute vec3 position : POSITION;
varying vec4 v_ViewPosition;
void main(){

    v_ViewPosition = worldViewProjection * vec4( position, 1.0 );
    gl_Position = worldViewProjection * vec4( position , 1.0 );

}
@end



@export buildin.sm.depth.fragment

varying vec4 v_ViewPosition;

@import buildin.util.pack_depth

void main(){
    // Whats the difference between gl_FragCoord.z and this v_ViewPosition
    // gl_FragCoord consider the polygon offset ?
    float z = v_ViewPosition.z / v_ViewPosition.w;

    gl_FragColor = packDepth(z * 0.5 + 0.5);
}
@end



@export buildin.plugin.compute_shadow_map

#if defined( SHADOWMAP_ENABLED ) && defined( SHADOWMAP_NUMBER )

@import buildin.util.unpack_depth

float computeShadowFalloffOfSingleMap(sampler2D map, mat4 lightVPM, vec3 position){
    float shadowFallOff = 1.0;
    for( int i = 0; i < SHADOWMAP_NUMBER; i++){
        vec4 posInLightSpace = ( shadowCameraMatrix[i] * vec4(v_WorldPosition, 1.0) );
        posInLightSpace.xyz /= posInLightSpace.w;
        // In frustum
        if( all(greaterThan(posInLightSpace.xyz, vec3(-1.0))) &&
            all(lessThan(posInLightSpace.xyz, vec3(1.0))) ){
            // To texture uv
            vec2 uv = (posInLightSpace.xy+1.0) / 2.0;
            vec4 shadowTex = texture2D( shadowMap[i], uv );
            float z = unpackDepth(shadowTex);
            
            if( z + 0.001 < posInLightSpace.z ){
                shadowFallOff = 0.2;
            }
        }
    }
    return shadowFallOff;
}

#if defined(SPOT_LIGHT_NUMBER) && defined(SPOT_LIGHT_SHADOWMAP_NUMBER)

void computeShadowFallOfSpotLights( vec3 position, inout float shadowFalloffs[SPOT_LIGHT_NUMBER]  ){
    for( int i = SPOT_LIGHT_SHADOWMAP_OFFSET; i < SPOT_LIGHT_SHADOWMAP_OFFSET + SPOT_LIGHT_SHADOWMAP_NUMBER; i++){
        float shadowFalloff = computeShadowFalloffOfSingleMap( shadowMap[i], shadowCameraMatrix[i], position );
        shadowFalloffs[ i - SPOT_LIGHT_SHADOWMAP_OFFSET ] = shadowFalloff;
    }
    // set default fallof of rest lights
    for( int i = SPOT_LIGHT_SHADOWMAP_NUMBER; i < SPOT_LIGHT_NUMBER; i++){
        shadowFalloffs[i] = 1.0;
    }
}

#endif


#if defined(POINT_LIGHT_NUMBER) && defined(POINT_LIGHT_SHADOWMAP_NUMBER)

void computeShadowFallOfPointLights( vec3 position, inout float shadowFalloffs[POINT_LIGHT_NUMBER]  ){
    for( int i = 0; i < POINT_LIGHT_NUMBER; i++){
        shadowFalloffs[i] = 1.0;
    }
    for( int i = POINT_LIGHT_SHADOWMAP_OFFSET; i < POINT_LIGHT_SHADOWMAP_OFFSET + POINT_LIGHT_SHADOWMAP_NUMBER; i++){
        float shadowFalloff = computeShadowFalloffOfSingleMap( shadowMap[i], shadowCameraMatrix[i], position );
        
        shadowFalloffs[ (i - POINT_LIGHT_SHADOWMAP_OFFSET) / 6 ] *= shadowFalloff;
    }
}

#endif


#if defined(DIRECTIONAL_LIGHT_NUMBER) && defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)

void computeShadowFallOfDirectionalLights( vec3 position, inout float shadowFalloffs[DIRECTIONAL_LIGHT_NUMBER] ){
    for( int i = DIRECTIONAL_LIGHT_SHADOWMAP_OFFSET; i < DIRECTIONAL_LIGHT_SHADOWMAP_OFFSET + DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i++){
        float shadowFalloff = computeShadowFalloffOfSingleMap( shadowMap[i], shadowCameraMatrix[i], position );
        shadowFalloffs[ i - POINT_LIGHT_SHADOWMAP_OFFSET] = shadowFalloff;
    }
    // set default fallof of rest lights
    for( int i = DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i < DIRECTIONAL_LIGHT_NUMBER; i++){
        shadowFalloffs[i] = 1.0;
    }
}

#endif

#endif

@end