/**
 * NORMAL
 */
@export buildin.sm.depth.vertex

uniform mat4 worldViewProjection : WORLDVIEWPROJECTION;

attribute vec3 position : POSITION;

#ifdef SKINNING
attribute vec3 boneWeight;
attribute vec4 boneIndex;

uniform mat4 boneMatrices[ BONE_MATRICES_NUMBER ];
#endif

varying vec4 v_ViewPosition;
void main(){
    
    vec3 skinnedPosition = position;
    #ifdef SKINNING
        mat4 skinMatrix;
        if(boneIndex.x >= 0.0){
            skinMatrix = boneMatrices[int(boneIndex.x)] * boneWeight.x;
        }
        if(boneIndex.y >= 0.0){
            skinMatrix += boneMatrices[int(boneIndex.y)] * boneWeight.y;
        }
        if(boneIndex.z >= 0.0){
            skinMatrix += boneMatrices[int(boneIndex.z)] * boneWeight.z;
        }
        if(boneIndex.w >= 0.0){
            skinMatrix += boneMatrices[int(boneIndex.w)] * (1.0-boneWeight.x-boneWeight.y-boneWeight.z);
        }
        skinnedPosition = (skinMatrix * vec4(position, 1.0)).xyz;
    #endif

    v_ViewPosition = worldViewProjection * vec4(skinnedPosition, 1.0);
    gl_Position = v_ViewPosition;

}
@end
////////////////////////////////////////////////////////////////
@export buildin.sm.depth.fragment

varying vec4 v_ViewPosition;

@import buildin.util.pack_depth

void main(){
    // Whats the difference between gl_FragCoord.z and this v_ViewPosition
    // gl_FragCoord consider the polygon offset ?
    float z = v_ViewPosition.z / v_ViewPosition.w;
    // Map to 0.0 - 1.0
    gl_FragColor = packDepth((z + 1.0) / 2.0);
}
@end



@export buildin.sm.distance.vertex

uniform mat4 worldViewProjection : WORLDVIEWPROJECTION;
uniform mat4 world : WORLD;

attribute vec3 position : POSITION;

#ifdef SKINNING
attribute vec3 boneWeight;
attribute vec4 boneIndex;

uniform mat4 boneMatrices[ BONE_MATRICES_NUMBER ];
#endif

varying vec3 v_WorldPosition;

void main(){

    vec3 skinnedPosition = position;
    #ifdef SKINNING
        mat4 skinMatrix;
        if(boneIndex.x >= 0.0){
            skinMatrix = boneMatrices[int(boneIndex.x)] * boneWeight.x;
        }
        if(boneIndex.y >= 0.0){
            skinMatrix += boneMatrices[int(boneIndex.y)] * boneWeight.y;
        }
        if(boneIndex.z >= 0.0){
            skinMatrix += boneMatrices[int(boneIndex.z)] * boneWeight.z;
        }
        if(boneIndex.w >= 0.0){
            skinMatrix += boneMatrices[int(boneIndex.w)] * (1.0-boneWeight.x-boneWeight.y-boneWeight.z);
        }
        skinnedPosition = (skinMatrix * vec4(position, 1.0)).xyz;
    #endif

    gl_Position = worldViewProjection * vec4( skinnedPosition , 1.0 );
    v_WorldPosition = ( world * vec4(skinnedPosition, 1.0) ).xyz;
}

@end

@export buildin.sm.distance.fragment

uniform vec3 lightPosition;

varying vec3 v_WorldPosition;

@import buildin.util.pack_depth

void main(){

    float dist = distance(lightPosition, v_WorldPosition);

    gl_FragColor = packDepth( dist );
}
@end

/**
 * PCF
 */


////////////////////////////////////////////////////////////////
@export buildin.plugin.compute_shadow_map

#if defined(SPOT_LIGHT_SHADOWMAP_NUMBER) || defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER) || defined(POINT_LIGHT_SHADOWMAP_NUMBER)

#ifdef SPOT_LIGHT_SHADOWMAP_NUMBER
uniform sampler2D spotLightShadowMap[ SPOT_LIGHT_SHADOWMAP_NUMBER ];
uniform mat4 spotLightMatrix[ SPOT_LIGHT_SHADOWMAP_NUMBER ]; 
#endif

#ifdef DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER
uniform sampler2D directionalLightShadowMap[ DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER ];
uniform mat4 directionalLightMatrix[ DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER ];
#endif

#ifdef POINT_LIGHT_SHADOWMAP_NUMBER
uniform samplerCube pointLightShadowMap[ POINT_LIGHT_SHADOWMAP_NUMBER ];
#endif

uniform bool shadowEnabled : true;

// Normal
@import buildin.util.unpack_depth

#if defined(DIRECTIONAL_LIGHT_NUMBER) || defined(SPOT_LIGHT_SHADOWMAP_NUMBER)

float shadowContrib(sampler2D map, vec2 uv, float z){
    vec4 tex = texture2D(map, uv);
    return (unpackDepth(tex) * 2.0 - 1.0) + 0.003 < z ? 0.0 : 1.0;
}

float pcf(sampler2D map, vec2 uv, float z){

    float shadowFalloff = shadowContrib(map, uv, z);
    float offset = 1.0/512.0;
    shadowFalloff += shadowContrib(map, uv+vec2(offset, 0.0), z);
    shadowFalloff += shadowContrib(map, uv+vec2(offset, offset), z);
    shadowFalloff += shadowContrib(map, uv+vec2(-offset, offset), z);
    shadowFalloff += shadowContrib(map, uv+vec2(0.0, offset), z);
    shadowFalloff += shadowContrib(map, uv+vec2(-offset, 0.0), z);
    shadowFalloff += shadowContrib(map, uv+vec2(-offset, -offset), z);
    shadowFalloff += shadowContrib(map, uv+vec2(offset, -offset), z);
    shadowFalloff += shadowContrib(map, uv+vec2(0.0, -offset), z);

    return shadowFalloff / 9.0;
}

float computeShadowFalloff(sampler2D map, mat4 lightVPM, vec3 position){
    float shadowFalloff = 1.0;
    vec4 posInLightSpace = lightVPM * vec4(v_WorldPosition, 1.0);
    posInLightSpace.xyz /= posInLightSpace.w;
    // In frustum
    if( all(greaterThan(posInLightSpace.xyz, vec3(-1.0))) &&
        all(lessThan(posInLightSpace.xyz, vec3(1.0))) ){
        // To texture uv
        vec2 uv = (posInLightSpace.xy+1.0) / 2.0;

        shadowFalloff = pcf(map, uv, posInLightSpace.z);
    }
    return shadowFalloff;
}

#endif

#ifdef POINT_LIGHT_SHADOWMAP_NUMBER

float computeShadowFallOfCube( samplerCube map, vec3 direction ){
    vec4 shadowTex = textureCube(map, direction);
    float dist = length(direction);

    if( unpackDepth(shadowTex) + 0.002 < dist ){
        return 0.0;
    }else{
        return 1.0;
    }
}
#endif

#if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)

void computeShadowFallOfSpotLights( vec3 position, inout float shadowFalloffs[SPOT_LIGHT_NUMBER]  ){
    for( int i = 0; i < SPOT_LIGHT_SHADOWMAP_NUMBER; i++){
        float shadowFalloff = computeShadowFalloff( spotLightShadowMap[i], spotLightMatrix[i], position );
        shadowFalloffs[ i ] = shadowFalloff;
    }
    // set default fallof of rest lights
    for( int i = SPOT_LIGHT_SHADOWMAP_NUMBER; i < SPOT_LIGHT_NUMBER; i++){
        shadowFalloffs[i] = 1.0;
    }
}

#endif


#if defined(POINT_LIGHT_SHADOWMAP_NUMBER)

void computeShadowFallOfPointLights( vec3 position, inout float shadowFalloffs[POINT_LIGHT_NUMBER]  ){
    for( int i = 0; i < POINT_LIGHT_SHADOWMAP_NUMBER; i++){
        vec3 lightPosition = pointLightPosition[i];
        vec3 direction = position - lightPosition;
        shadowFalloffs[ i ] = computeShadowFallOfCube( pointLightShadowMap[i], direction );
    }
    for( int i = POINT_LIGHT_SHADOWMAP_NUMBER; i < POINT_LIGHT_NUMBER; i++){
        shadowFalloffs[i] = 1.0;
    }
}

#endif


#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)

void computeShadowFallOfDirectionalLights( vec3 position, inout float shadowFalloffs[DIRECTIONAL_LIGHT_NUMBER] ){
    for( int i = 0; i < DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i++){
        float shadowFalloff = computeShadowFalloff( directionalLightShadowMap[i], directionalLightMatrix[i], position );
        shadowFalloffs[i] = shadowFalloff;
    }
    // set default fallof of rest lights
    for( int i = DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i < DIRECTIONAL_LIGHT_NUMBER; i++){
        shadowFalloffs[i] = 1.0;
    }
}

#endif

#endif

@end